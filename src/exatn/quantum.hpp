/** ExaTN: Quantum computing related
REVISION: 2021/10/26

Copyright (C) 2018-2021 Dmitry I. Lyakh (Liakh)
Copyright (C) 2018-2021 Oak Ridge National Laboratory (UT-Battelle) **/

/** Rationale:
 a) Provides utilities related to quantum circuit simulations, like quantum gates,
    Pauli matrix based Hamiltonian reading or generation, etc.
 b) Normal gate action translates to the following tensor notation:
     q(j0) * G(j0|i0) --> v(i0),
     q(j1,j0) * G(j1,j0|i1,i0) --> v(i1,i0), etc,
    where the inverse order of indices and the transposed
    form of the equations is a consequence of the column-wise
    storage of matrix G(j1,j0|i1,i0), to match the textbook
    definitions of quantum gates. Note that if G(j1,j0|i1,i0)
    is a controlled 2-body gate, the control (senior) indices
    are i0 and j0. A convenient way to remember this is to
    adhere to the bra convention such that we will have:
     <v(i1,i0)| = <q(j1,j0)| * CX(j1,j0|i1,i0), where
    the CX gate is applied to a 2-qubit register q.
**/

#ifndef EXATN_QUANTUM_HPP_
#define EXATN_QUANTUM_HPP_

#include "exatn_numerics.hpp"
#include "tensor_operator.hpp"
#include "tensor_symbol.hpp"
#include "tensor_range.hpp"

#include <functional>
#include <vector>
#include <complex>
#include <string>

#include "errors.hpp"

namespace exatn{

namespace quantum{

enum class Gate{
 gate_0,
 gate_I,
 gate_X,
 gate_Y,
 gate_Z,
 gate_H,
 gate_S,
 gate_T,
 gate_CX,
 gate_CY,
 gate_CZ,
 gate_SWAP,
 gate_ISWAP
};

//Pauli gate acting on a specific qubit:
struct PauliMap {
 Gate pauli_gate;   //Pauli gate (I,X,Y,Z)
 std::size_t qubit; //flattened qubit id
};

//Product of Pauli gates:
struct PauliProduct {
 std::vector<PauliMap> product;              //product of Pauli maps
 std::complex<double> coefficient {0.0,0.0}; //linear combination coefficient
};


/** Returns the data initialization vector for a specific quantum gate
    that can subsequently be used for initializing its tensor.
**/
std::vector<std::complex<double>> getGateData(const Gate gate_name,
                                              std::initializer_list<double> angles = {});

/** Creates a tensor network operator for a given spin Hamiltonian
    represented as a linear combination of Pauli strings. Supported formats:
    + "OpenFermion": Open Fermion format (default);
    + "QCWare": QCWare collab format (by Rob Parrish);
**/
std::shared_ptr<exatn::numerics::TensorOperator> readSpinHamiltonian(const std::string & operator_name,
                                                                     const std::string & filename,
                                                                     TensorElementType precision = TensorElementType::COMPLEX64,
                                                                     const std::string & format = "OpenFermion");

/** Generates a grid-based spin Hamiltonian of the form:
     H = Sum{i1,...,iK} [H(i1,...,iK) * P(i1) * ... * P(iK)],
    where P(i) is a Pauli matrix acting on spin site i. In general,
    the index i enumerating the spin sites is a flattened D-dimensional
    multi-index, where D is the dimensionality of the spin grid.
    In general, the Sum can contain Pauli matrix products of varying
    length, K. The constituting individual Pauli matrix products are
    generated by the provided Lambda generator <hamiltonian_generator>
    which is supposed to return an individual PauliProduct upon each
    invocation (in their respective order). The end of the generated
    sequence is signalled by an empty PauliProduct with zero coefficient.
**/
std::shared_ptr<exatn::numerics::TensorOperator> generateSpinHamiltonian(const std::string & operator_name,
                                                  std::function<PauliProduct ()> hamiltonian_generator,
                                                  TensorElementType precision = TensorElementType::COMPLEX64);

} //namespace quantum

} //namespace exatn

#endif //EXATN_QUANTUM_HPP_
